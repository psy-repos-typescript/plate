{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ai-api",
  "type": "registry:file",
  "dependencies": [
    "@ai-sdk/react@2.0.28",
    "ai@5.0.28",
    "dedent@1.0.0"
  ],
  "registryDependencies": [
    "https://platejs.org/r/copilot-api",
    "https://platejs.org/r/markdown-joiner-transform"
  ],
  "files": [
    {
      "path": "src/registry/app/api/ai/command/route.ts",
      "content": "import type {\n  ChatMessage,\n  ToolName,\n} from '@/registry/components/editor/use-chat';\nimport type { NextRequest } from 'next/server';\n\nimport { createGateway } from '@ai-sdk/gateway';\nimport {\n  type LanguageModel,\n  type UIMessageStreamWriter,\n  createUIMessageStream,\n  createUIMessageStreamResponse,\n  generateObject,\n  streamObject,\n  streamText,\n  tool,\n} from 'ai';\nimport { NextResponse } from 'next/server';\nimport { type SlateEditor, createSlateEditor, nanoid } from 'platejs';\nimport { z } from 'zod';\n\nimport { BaseEditorKit } from '@/registry/components/editor/editor-base-kit';\nimport { markdownJoinerTransform } from '@/registry/lib/markdown-joiner-transform';\n\nimport {\n  getChooseToolPrompt,\n  getCommentPrompt,\n  getEditPrompt,\n  getGeneratePrompt,\n} from './prompts';\n\nexport async function POST(req: NextRequest) {\n  const { apiKey: key, ctx, messages: messagesRaw, model } = await req.json();\n\n  const { children, selection, toolName: toolNameParam } = ctx;\n\n  const editor = createSlateEditor({\n    plugins: BaseEditorKit,\n    selection,\n    value: children,\n  });\n\n  const apiKey = key || process.env.AI_GATEWAY_API_KEY;\n\n  if (!apiKey) {\n    return NextResponse.json(\n      { error: 'Missing AI Gateway API key.' },\n      { status: 401 }\n    );\n  }\n\n  const isSelecting = editor.api.isExpanded();\n\n  const gatewayProvider = createGateway({\n    apiKey,\n  });\n\n  try {\n    const stream = createUIMessageStream<ChatMessage>({\n      execute: async ({ writer }) => {\n        let toolName = toolNameParam;\n\n        if (!toolName) {\n          const { object: AIToolName } = await generateObject({\n            enum: isSelecting\n              ? ['generate', 'edit', 'comment']\n              : ['generate', 'comment'],\n            model: gatewayProvider(model || 'google/gemini-2.5-flash'),\n            output: 'enum',\n            prompt: getChooseToolPrompt(messagesRaw),\n          });\n\n          writer.write({\n            data: AIToolName as ToolName,\n            type: 'data-toolName',\n          });\n\n          toolName = AIToolName;\n        }\n\n        const stream = streamText({\n          experimental_transform: markdownJoinerTransform(),\n          model: gatewayProvider(model || 'openai/gpt-4o-mini'),\n          // Not used\n          prompt: '',\n          tools: {\n            comment: getCommentTool(editor, {\n              messagesRaw,\n              model: gatewayProvider(model || 'google/gemini-2.5-flash'),\n              writer,\n            }),\n          },\n          prepareStep: async (step) => {\n            if (toolName === 'comment') {\n              return {\n                ...step,\n                toolChoice: { toolName: 'comment', type: 'tool' },\n              };\n            }\n\n            if (toolName === 'edit') {\n              const editPrompt = getEditPrompt(editor, {\n                isSelecting,\n                messages: messagesRaw,\n              });\n\n              return {\n                ...step,\n                activeTools: [],\n                messages: [\n                  {\n                    content: editPrompt,\n                    role: 'user',\n                  },\n                ],\n              };\n            }\n\n            if (toolName === 'generate') {\n              const generatePrompt = getGeneratePrompt(editor, {\n                messages: messagesRaw,\n              });\n\n              return {\n                ...step,\n                activeTools: [],\n                messages: [\n                  {\n                    content: generatePrompt,\n                    role: 'user',\n                  },\n                ],\n                model: gatewayProvider(model || 'openai/gpt-4o-mini'),\n              };\n            }\n          },\n        });\n\n        writer.merge(stream.toUIMessageStream({ sendFinish: false }));\n      },\n    });\n\n    return createUIMessageStreamResponse({ stream });\n  } catch {\n    return NextResponse.json(\n      { error: 'Failed to process AI request' },\n      { status: 500 }\n    );\n  }\n}\n\nconst getCommentTool = (\n  editor: SlateEditor,\n  {\n    messagesRaw,\n    model,\n    writer,\n  }: {\n    messagesRaw: ChatMessage[];\n    model: LanguageModel;\n    writer: UIMessageStreamWriter<ChatMessage>;\n  }\n) => {\n  return tool({\n    description: 'Comment on the content',\n    inputSchema: z.object({}),\n    execute: async () => {\n      const { elementStream } = streamObject({\n        model,\n        output: 'array',\n        prompt: getCommentPrompt(editor, {\n          messages: messagesRaw,\n        }),\n        schema: z\n          .object({\n            blockId: z\n              .string()\n              .describe(\n                'The id of the starting block. If the comment spans multiple blocks, use the id of the first block.'\n              ),\n            comment: z\n              .string()\n              .describe('A brief comment or explanation for this fragment.'),\n            content: z\n              .string()\n              .describe(\n                String.raw`The original document fragment to be commented on.It can be the entire block, a small part within a block, or span multiple blocks. If spanning multiple blocks, separate them with two \\n\\n.`\n              ),\n          })\n          .describe('A single comment'),\n      });\n\n      for await (const comment of elementStream) {\n        const commentDataId = nanoid();\n\n        writer.write({\n          id: commentDataId,\n          data: {\n            comment: comment,\n            status: 'streaming',\n          },\n          type: 'data-comment',\n        });\n      }\n\n      writer.write({\n        id: nanoid(),\n        data: {\n          comment: null,\n          status: 'finished',\n        },\n        type: 'data-comment',\n      });\n    },\n  });\n};\n",
      "type": "registry:file",
      "target": "app/api/ai/command/route.ts"
    },
    {
      "path": "src/registry/app/api/ai/command/utils.ts",
      "content": "import type { ChatMessage } from '@/registry/components/editor/use-chat';\nimport type { UIMessage } from 'ai';\n\nimport { getMarkdown } from '@platejs/ai';\nimport { serializeMd } from '@platejs/markdown';\nimport dedent from 'dedent';\nimport { type SlateEditor, RangeApi } from 'platejs';\n\n/**\n * Tag content split by newlines\n *\n * @example\n *   <tools>\n *   {content}\n *   </tools>\n */\nexport const tag = (tag: string, content?: string | null) => {\n  if (!content) return '';\n\n  return [`<${tag}>`, content, `</${tag}>`].join('\\n');\n};\n\n/**\n * Tag content inline\n *\n * @example\n *   <tools>{content}</tools>\n */\nexport const inlineTag = (tag: string, content?: string | null) => {\n  if (!content) return '';\n\n  return [`<${tag}>`, content, `</${tag}>`].join('');\n};\n\n// Sections split by double newlines\nexport const sections = (sections: (boolean | string | null | undefined)[]) => {\n  return sections.filter(Boolean).join('\\n\\n');\n};\n\n// List items split by newlines\nexport const list = (items: string[] | undefined) => {\n  return items\n    ? items\n        .filter(Boolean)\n        .map((item) => `- ${item}`)\n        .join('\\n')\n    : '';\n};\n\nexport type StructuredPromptSections = {\n  backgroundData?: string;\n  examples?: string[] | string;\n  history?: string;\n  outputFormatting?: string;\n  prefilledResponse?: string;\n  question?: string;\n  rules?: string;\n  task?: string;\n  taskContext?: string;\n  thinking?: string;\n  tone?: string;\n  tools?: string;\n};\n\n/**\n * Build a structured prompt following best practices for AI interactions.\n *\n * @example\n *   https://imgur.com/carbon-Db5tDUh\n *   1. Task context - You will be acting as an AI career coach named Joe created by the company\n *   AdAstra Careers. Your goal is to give career advice to users. You will be replying to users\n *   who are on the AdAstra site and who will be confused if you don't respond in the character of Joe.\n *   2. Tone context - You should maintain a friendly customer service tone.\n *   3. Background data - Here is the career guidance document you should reference when answering the user: <guide>{DOCUMENT}</guide>\n *   3b. Tools - Available tool descriptions\n *   4. Rules - Here are some important rules for the interaction:\n *   - Always stay in character, as Joe, an AI from AdAstra careers\n *   - If you are unsure how to respond, say \"Sorry, I didn't understand that. Could you repeat the question?\"\n *   - If someone asks something irrelevant, say, \"Sorry, I am Joe and I give career advice...\"\n *   5. Examples - Here is an example of how to respond in a standard interaction:\n *   <example>\n *   User: Hi, how were you created and what do you do?\n *   Joe: Hello! My name is Joe, and I was created by AdAstra Careers to give career advice...\n *   </example>\n *   6. Conversation history - Here is the conversation history (between the user and you) prior to the question. <history>{HISTORY}</history>\n *   6b. Question - Here is the user's question: <question>{QUESTION}</question>\n *   7. Immediate task - How do you respond to the user's question?\n *   8. Thinking - Think about your answer first before you respond.\n *   9. Output formatting - Put your response in <response></response> tags.\n *   11. Prefilled response - Optional response starter\n */\nexport const buildStructuredPrompt = ({\n  backgroundData,\n  examples,\n  history,\n  outputFormatting,\n  prefilledResponse,\n  question,\n  rules,\n  task,\n  taskContext,\n  thinking,\n  tone,\n}: StructuredPromptSections) => {\n  const formattedExamples = Array.isArray(examples)\n    ? examples.map((example) => tag('example', example)).join('\\n')\n    : examples;\n\n  const context = sections([\n    taskContext,\n    tone,\n\n    backgroundData &&\n      dedent`\n        Here is the background data you should reference when answering the user:\n        <backgroundData>\n              ${backgroundData}\n        </backgroundData>\n      `,\n    rules &&\n      dedent`\n        Here are some important rules for the interaction:\n            ${rules}\n      `,\n\n    formattedExamples &&\n      dedent`\n        Here are some examples of how to respond in a standard interaction:\n              ${tag('examples', formattedExamples)}\n      `,\n\n    history &&\n      dedent`\n        Here is the conversation history (between the user and you) prior to the question:\n              ${tag('history', history)}\n      `,\n\n    question &&\n      dedent`\n        Here is the user's question:\n              ${tag('question', question)}\n      `,\n  ]);\n\n  return sections([\n    tag('context', context),\n    task,\n    // or <reasoningSteps>\n    thinking && tag('thinking', thinking),\n    // Not needed with structured output\n    outputFormatting && tag('outputFormatting', outputFormatting),\n    // Not needed with structured output\n    (prefilledResponse ?? null) !== null &&\n      tag('prefilledResponse', prefilledResponse ?? ''),\n  ]);\n};\n\nexport function getTextFromMessage(message: UIMessage): string {\n  return message.parts\n    .filter((part) => part.type === 'text')\n    .map((part) => part.text)\n    .join('');\n}\n\n/**\n * Format conversation history for prompts. Extracts text from messages and\n * formats as ROLE: text.\n */\nexport function formatTextFromMessages(\n  messages: ChatMessage[],\n  options?: { limit?: number }\n): string {\n  const historyMessages = options?.limit\n    ? messages.slice(-options.limit)\n    : messages;\n\n  return historyMessages\n    .map((message) => {\n      const text = getTextFromMessage(message).trim();\n      if (!text) return null;\n      const role = message.role.toUpperCase();\n      return `${role}: ${text}`;\n    })\n    .filter(Boolean)\n    .join('\\n');\n}\n\nconst SELECTION_START = '<Selection>';\nconst SELECTION_END = '</Selection>';\n\nexport const addSelection = (editor: SlateEditor) => {\n  if (!editor.selection) return;\n  if (editor.api.isExpanded()) {\n    const [start, end] = RangeApi.edges(editor.selection);\n\n    editor.tf.withoutNormalizing(() => {\n      editor.tf.insertText(SELECTION_END, {\n        at: end,\n      });\n\n      editor.tf.insertText(SELECTION_START, {\n        at: start,\n      });\n    });\n  }\n};\n\nconst removeEscapeSelection = (editor: SlateEditor, text: string) => {\n  let newText = text\n    .replace(`\\\\${SELECTION_START}`, SELECTION_START)\n    .replace(`\\\\${SELECTION_END}`, SELECTION_END);\n\n  // If the selection is on a void element, inserting the placeholder will fail, and the string must be replaced manually.\n  if (!newText.includes(SELECTION_END)) {\n    const [_, end] = RangeApi.edges(editor.selection!);\n\n    const node = editor.api.block({ at: end.path });\n\n    if (!node) return newText;\n    if (editor.api.isVoid(node[0])) {\n      const voidString = serializeMd(editor, { value: [node[0]] });\n\n      const idx = newText.lastIndexOf(voidString);\n\n      if (idx !== -1) {\n        newText =\n          newText.slice(0, idx) +\n          voidString.trimEnd() +\n          SELECTION_END +\n          newText.slice(idx + voidString.length);\n      }\n    }\n  }\n\n  return newText;\n};\n\n/** Check if the current selection fully covers all top-level blocks. */\nexport const isMultiBlocks = (editor: SlateEditor) => {\n  const blocks = editor.api.blocks({ mode: 'highest' });\n\n  return blocks.length > 1;\n};\n\n/** Get markdown with selection markers */\nexport const getMarkdownWithSelection = (editor: SlateEditor) => {\n  return removeEscapeSelection(editor, getMarkdown(editor, { type: 'block' }));\n};\n",
      "type": "registry:file",
      "target": "app/api/ai/command/utils.ts"
    },
    {
      "path": "src/registry/app/api/ai/command/prompts.ts",
      "content": "import type { ChatMessage } from '@/registry/components/editor/use-chat';\nimport type { SlateEditor } from 'platejs';\n\nimport { getMarkdown } from '@platejs/ai';\nimport dedent from 'dedent';\n\nimport {\n  addSelection,\n  buildStructuredPrompt,\n  formatTextFromMessages,\n  getMarkdownWithSelection,\n  isMultiBlocks,\n} from './utils';\n\nexport function getChooseToolPrompt({ messages }: { messages: ChatMessage[] }) {\n  return buildStructuredPrompt({\n    examples: [\n      // GENERATE\n      'User: \"Write a paragraph about AI ethics\" → Good: \"generate\" | Bad: \"edit\"',\n      'User: \"Create a short poem about spring\" → Good: \"generate\" | Bad: \"comment\"',\n\n      // EDIT\n      'User: \"Please fix grammar.\" → Good: \"edit\" | Bad: \"generate\"',\n      'User: \"Improving writing style.\" → Good: \"edit\" | Bad: \"generate\"',\n      'User: \"Making it more concise.\" → Good: \"edit\" | Bad: \"generate\"',\n      'User: \"Translate this paragraph into French\" → Good: \"edit\" | Bad: \"generate\"',\n\n      // COMMENT\n      'User: \"Can you review this text and give me feedback?\" → Good: \"comment\" | Bad: \"edit\"',\n      'User: \"Add inline comments to this code to explain what it does\" → Good: \"comment\" | Bad: \"generate\"',\n    ],\n    history: formatTextFromMessages(messages),\n    rules: dedent`\n      - Default is \"generate\". Any open question, idea request, or creation request → \"generate\".\n      - Only return \"edit\" if the user provides original text (or a selection of text) AND asks to change, rephrase, translate, or shorten it.\n      - Only return \"comment\" if the user explicitly asks for comments, feedback, annotations, or review. Do not infer \"comment\" implicitly.\n      - Return only one enum value with no explanation.\n    `,\n    task: `You are a strict classifier. Classify the user's last request as \"generate\", \"edit\", or \"comment\".`,\n  });\n}\n\nexport function getCommentPrompt(\n  editor: SlateEditor,\n  {\n    messages,\n  }: {\n    messages: ChatMessage[];\n  }\n) {\n  const selectingMarkdown = getMarkdown(editor, {\n    type: 'blockWithBlockId',\n  });\n\n  return buildStructuredPrompt({\n    backgroundData: selectingMarkdown,\n    examples: [\n      // 1) Basic single-block comment\n      `User: Review this paragraph.\n\n    backgroundData:\n  <block id=\"1\">AI systems are transforming modern workplaces by automating routine tasks.</block>\n\n  Output:\n  [\n    {\n      \"blockId\": \"1\",\n      \"content\": \"AI systems are transforming modern workplaces\",\n      \"comments\": \"Clarify what types of systems or provide examples.\"\n    }\n  ]`,\n\n      // 2) Multiple comments within one long block\n      `User: Add comments for this section.\n\n  backgroundData:\n  <block id=\"2\">AI models can automate customer support. However, they may misinterpret user intent if training data is biased.</block>\n\n  Output:\n  [\n    {\n      \"blockId\": \"2\",\n      \"content\": \"AI models can automate customer support.\",\n      \"comments\": \"Consider mentioning limitations or scope of automation.\"\n    },\n    {\n      \"blockId\": \"2\",\n      \"content\": \"they may misinterpret user intent if training data is biased\",\n      \"comments\": \"Good point—expand on how bias can be detected or reduced.\"\n    }\n  ]`,\n\n      // 3) Multi-block comment (span across two related paragraphs)\n      `User: Provide comments.\n\n  backgroundData:\n  <block id=\"3\">This policy aims to regulate AI-generated media.</block>\n  <block id=\"4\">Developers must disclose when content is synthetically produced.</block>\n\n  Output:\n  [\n    {\n      \"blockId\": \"3\",\n      \"content\": \"This policy aims to regulate AI-generated media.\\\\n\\\\nDevelopers must disclose when content is synthetically produced.\",\n      \"comments\": \"You could combine these ideas into a single, clearer statement on transparency.\"\n    }\n  ]`,\n\n      // 4) With <Selection> – user highlighted part of a sentence\n      `User: Give feedback on this highlighted phrase.\n\n  backgroundData:\n  <block id=\"5\">AI can <Selection>replace human creativity</Selection> in design tasks.</block>\n\n  Output:\n  [\n    {\n      \"blockId\": \"5\",\n      \"content\": \"replace human creativity\",\n      \"comments\": \"Overstated claim—suggest using 'assist' instead of 'replace'.\"\n    }\n  ]`,\n\n      // 5) With long <Selection> → multiple comments\n      `User: Review the highlighted section.\n\n  backgroundData:\n  <block id=\"6\">\n  <Selection>\n  AI tools are valuable for summarizing information and generating drafts.\n  Still, human review remains essential to ensure accuracy and ethical use.\n  </Selection>\n  </block>\n\n  Output:\n  [\n    {\n      \"blockId\": \"6\",\n      \"content\": \"AI tools are valuable for summarizing information and generating drafts.\",\n      \"comments\": \"Solid statement—consider adding specific examples of tools.\"\n    },\n    {\n      \"blockId\": \"6\",\n      \"content\": \"human review remains essential to ensure accuracy and ethical use\",\n      \"comments\": \"Good caution—explain briefly why ethics require human oversight.\"\n    }\n  ]`,\n    ],\n    history: formatTextFromMessages(messages),\n    rules: dedent`\n      - IMPORTANT: If a comment spans multiple blocks, use the id of the **first** block.\n      - The **content** field must be the original content inside the block tag. The returned content must not include the block tags, but should retain other MDX tags.\n      - IMPORTANT: The **content** field must be flexible:\n        - It can cover one full block, only part of a block, or multiple blocks.\n        - If multiple blocks are included, separate them with two \\\\n\\\\n.\n        - Do NOT default to using the entire block—use the smallest relevant span instead.\n      - At least one comment must be provided.\n      - If a <Selection> exists, Your comments should come from the <Selection>, and if the <Selection> is too long, there should be more than one comment.\n    `,\n    task: dedent`\n      You are a document review assistant.\n      You will receive an MDX document wrapped in <block id=\"...\"> content </block> tags.\n      <Selection> is the text highlighted by the user.\n\n      Your task:\n      - Read the content of all blocks and provide comments.\n      - For each comment, generate a JSON object:\n        - blockId: the id of the block being commented on.\n        - content: the original document fragment that needs commenting.\n        - comments: a brief comment or explanation for that fragment.\n    `,\n  });\n}\n\nexport function getGeneratePrompt(\n  editor: SlateEditor,\n  { messages }: { messages: ChatMessage[] }\n) {\n  !isMultiBlocks(editor) && addSelection(editor);\n\n  const selectingMarkdown = getMarkdownWithSelection(editor);\n\n  return buildStructuredPrompt({\n    backgroundData: selectingMarkdown,\n    examples: [\n      // 1) Summarize content\n      'User: Summarize the following text.\\nBackground data:\\nArtificial intelligence has transformed multiple industries, from healthcare to finance, improving efficiency and enabling data-driven decisions.\\nOutput:\\nAI improves efficiency and decision-making across many industries.',\n\n      // 2) Generate key takeaways\n      'User: List three key takeaways from this text.\\nBackground data:\\nRemote work increases flexibility but also requires better communication and time management.\\nOutput:\\n- Remote work enhances flexibility.\\n- Communication becomes critical.\\n- Time management determines success.',\n\n      // 3) Generate a title\n      'User: Generate a short, catchy title for this section.\\nBackground data:\\nThis section explains how machine learning models are trained using large datasets to recognize patterns.\\nOutput:\\nTraining Machines to Recognize Patterns',\n\n      // 4) Generate action items\n      'User: Generate actionable next steps based on the paragraph.\\nBackground data:\\nThe report suggests improving documentation and conducting user interviews before the next release.\\nOutput:\\n- Update all technical documentation.\\n- Schedule user interviews before the next release.',\n\n      // 5) Generate a comparison table\n      'User: Generate a comparison table of the tools mentioned.\\nBackground data:\\nTool A: free, simple UI\\nTool B: paid, advanced analytics\\nOutput:\\n| Tool  | Pricing | Features         |\\n|-------|----------|-----------------|\\n| A     | Free     | Simple UI        |\\n| B     | Paid     | Advanced analytics |',\n\n      // 6) Generate a summary table of statistics\n      'User: Create a summary table of the following statistics.\\nBackground data:\\nSales Q1: 1200 units\\nSales Q2: 1500 units\\nSales Q3: 900 units\\nOutput:\\n| Quarter | Sales (units) |\\n|----------|---------------|\\n| Q1       | 1200          |\\n| Q2       | 1500          |\\n| Q3       | 900           |',\n\n      // 7) Generate a question list\n      'User: Generate three reflection questions based on the paragraph.\\nBackground data:\\nThe article discusses the role of creativity in problem-solving and how diverse perspectives enhance innovation.\\nOutput:\\n1. How can creativity be encouraged in structured environments?\\n2. What role does diversity play in innovative teams?\\n3. How can leaders balance creativity and efficiency?',\n\n      // 8) Explain a concept (selected phrase)\n      'User: Explain the meaning of the selected phrase.\\nBackground data:\\nDeep learning relies on neural networks to automatically extract patterns from data, a process called <Selection>feature learning</Selection>.\\nOutput:\\n\"Feature learning\" means automatically discovering useful representations or characteristics from raw data without manual intervention.',\n    ],\n    history: formatTextFromMessages(messages),\n    rules: dedent`\n      - <Selection> is the text highlighted by the user.\n      - backgroundData represents the user's current Markdown context.\n      - You may only use backgroundData and <Selection> as input; never ask for more data.\n      - CRITICAL: DO NOT remove or alter custom MDX tags such as <u>, <callout>, <kbd>, <toc>, <sub>, <sup>, <mark>, <del>, <date>, <span>, <column>, <column_group>, <file>, <audio>, <video> unless explicitly requested.\n      - CRITICAL: when writing Markdown or MDX, do NOT wrap output in code fences.\n      - Preserve indentation and line breaks when editing within columns or structured layouts.\n    `,\n    task: dedent`\n      You are an advanced content generation assistant.\n      Generate content based on the user's instructions, using the background data as context.\n      If the instruction requests creation or transformation (e.g., summarize, translate, rewrite, create a table), directly produce the final result using only the provided background data.\n      Do not ask the user for additional content.\n    `,\n  });\n}\n\nexport function getEditPrompt(\n  editor: SlateEditor,\n  { isSelecting, messages }: { isSelecting: boolean; messages: ChatMessage[] }\n) {\n  if (!isSelecting)\n    throw new Error('Edit tool is only available when selecting');\n  if (isMultiBlocks(editor)) {\n    const selectingMarkdown = getMarkdownWithSelection(editor);\n\n    return buildStructuredPrompt({\n      backgroundData: selectingMarkdown,\n      examples: [\n        // 1) Fix grammar\n        'User: Fix grammar.\\nbackgroundData: # User Guide\\nThis guide explain how to install the app.\\nOutput:\\n# User Guide\\nThis guide explains how to install the application.',\n\n        // 2) Make the tone more formal and professional\n        \"User: Make the tone more formal and professional.\\nbackgroundData: ## Intro\\nHey, here's how you can set things up quickly.\\nOutput:\\n## Introduction\\nThis section describes the setup procedure in a clear and professional manner.\",\n\n        // 3) Make it more concise without losing meaning\n        'User: Make it more concise without losing meaning.\\nbackgroundData: The purpose of this document is to provide an overview that explains, in detail, all the steps required to complete the installation.\\nOutput:\\nThis document provides a detailed overview of the installation steps.',\n      ],\n      history: formatTextFromMessages(messages),\n      outputFormatting: 'markdown',\n      rules: dedent`\n        - Do not Write <backgroundData> tags in your response.\n        - <backgroundData> represents the full blocks of text the user has selected and wants to modify or ask about.\n        - Your response should be a direct replacement for the entire <backgroundData>.\n        - Maintain the overall structure and formatting of the background data, unless explicitly instructed otherwise.\n        - CRITICAL: Provide only the content to replace <backgroundData>. Do not add additional blocks or change the block structure unless specifically requested.\n      `,\n      task: `The following <backgroundData> is user-provided Markdown content that needs improvement. Modify it according to the user's instruction.\n      Unless explicitly stated otherwise, your output should be a seamless replacement of the original content.`,\n    });\n  }\n\n  addSelection(editor);\n\n  const selectingMarkdown = getMarkdownWithSelection(editor);\n  const endIndex = selectingMarkdown.indexOf('<Selection>');\n  const prefilledResponse = selectingMarkdown.slice(0, endIndex);\n\n  return buildStructuredPrompt({\n    backgroundData: selectingMarkdown,\n    examples: [\n      // 1) Improve word choice\n      'User: Improve word choice.\\nbackgroundData: This is a <Selection>nice</Selection> person.\\nOutput: great',\n\n      // 2) Fix grammar\n      'User: Fix grammar.\\nbackgroundData: He <Selection>go</Selection> to school every day.\\nOutput: goes',\n\n      // 3) Make tone more polite\n      'User: Make tone more polite.\\nbackgroundData: <Selection>Give me</Selection> the report.\\nOutput: Please provide',\n\n      // 4) Make tone more confident\n      'User: Make tone more confident.\\nbackgroundData: I <Selection>think</Selection> this might work.\\nOutput: believe',\n\n      // 5) Simplify language\n      'User: Simplify the language.\\nbackgroundData: The results were <Selection>exceedingly</Selection> positive.\\nOutput: very',\n\n      // 6) Translate into French\n      'User: Translate into French.\\nbackgroundData: <Selection>Hello</Selection>\\nOutput: Bonjour',\n\n      // 7) Expand description\n      'User: Expand the description.\\nbackgroundData: The view was <Selection>beautiful</Selection>.\\nOutput: breathtaking and full of vibrant colors',\n\n      // 8) Make it sound more natural\n      'User: Make it sound more natural.\\nbackgroundData: She <Selection>did a party</Selection> yesterday.\\nOutput: had a party',\n    ],\n    history: formatTextFromMessages(messages),\n    outputFormatting: 'markdown',\n    prefilledResponse,\n    rules: dedent`\n      - <Selection> contains the text segment selected by the user and allowed to be modified.\n      - Your response will be directly concatenated with the prefilledResponse, so please make sure the result is smooth and coherent.\n      - You may only edit the content inside <Selection> and must not reference or retain any external context.\n      - The output must be text that can directly replace <Selection>.\n      - Do not include the <Selection> tags or any surrounding text in the output.\n      - Ensure the replacement is grammatically correct and reads naturally.\n      - If the input is invalid or cannot be improved, return it unchanged.\n    `,\n    task: dedent`\n      The following background data is user-provided text that contains one or more <Selection> tags marking the editable parts.\n      You must only modify the text inside <Selection>.\n      Your output should be a direct replacement for the selected text, without including any tags or surrounding content.\n      Ensure the replacement is grammatically correct and fits naturally when substituted back into the original text.\n    `,\n  });\n}\n",
      "type": "registry:file",
      "target": "app/api/ai/command/prompts.ts"
    }
  ]
}